# 编译优化指南

## 快速开始

```bash
# 标准 Release 构建（推荐）
./build_release.sh

# 禁用 LTO（编译更快，但性能略低）
./build_release.sh --no-lto

# 启用快速数学（性能更好，但可能影响浮点精度）
./build_release.sh --fast-math
```

## 优化选项说明

### 1. 架构优化 (`-march=native -mtune=native`)
- **作用**：针对当前 CPU 架构优化
- **提升**：10-20%
- **说明**：自动检测 CPU 特性（AVX、SSE 等），生成最优代码

### 2. 链接时优化 (LTO, `-flto`)
- **作用**：跨模块优化，内联跨库函数
- **提升**：5-15%
- **代价**：编译时间增加 2-3 倍
- **建议**：生产环境启用，开发时可禁用

### 3. 循环展开 (`-funroll-loops`)
- **作用**：自动展开循环，减少分支开销
- **提升**：3-8%（对热点循环）
- **说明**：编译器自动判断是否展开

### 4. 内联优化 (`-finline-functions`)
- **作用**：更激进的内联策略
- **提升**：5-10%（减少函数调用开销）
- **代价**：代码体积可能增加

### 5. 快速数学 (`-ffast-math`)
- **作用**：放宽浮点运算限制，允许更多优化
- **提升**：10-30%（浮点密集代码）
- **风险**：可能改变浮点精度，需测试验证
- **建议**：仅在确认精度可接受时启用

### 6. 其他优化
- `-fomit-frame-pointer`: 省略帧指针，提升性能
- `-fstrict-aliasing`: 严格别名优化
- `-O3`: 最高级别优化

## 性能对比

| 配置 | 编译时间 | 运行性能 | 适用场景 |
|------|---------|---------|---------|
| 默认 Release | 1x | 基准 | 日常开发 |
| + LTO | 2-3x | +5-15% | 生产环境 |
| + Fast Math | 1x | +10-30% | 精度要求低 |
| 全部启用 | 2-3x | +20-50% | 极致性能 |

## 注意事项

1. **LTO 编译时间**：首次编译会较慢，后续增量编译影响较小
2. **Fast Math 精度**：启用前需充分测试，确保不影响交易逻辑
3. **架构兼容性**：`-march=native` 生成的二进制只能在相同架构 CPU 上运行
4. **调试难度**：优化后代码难以调试，建议保留 Debug 构建

## 推荐配置

### 生产环境（极致性能）
```bash
./build_release.sh --fast-math
```

### 开发环境（快速迭代）
```bash
./build_release.sh --no-lto
```

### 跨平台部署（兼容性优先）
修改 `CMakeLists.txt`，将 `-march=native` 改为 `-march=x86-64`
